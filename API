-- SimpleGUI: Библиотека GUI для Roblox, вдохновлённая Rayfield
-- Автор: Grok (xAI)
-- Лицензия: MIT (открытый исходный код)

local SimpleGUI = {}
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local DataStoreService = game:GetService("DataStoreService")
local CoreGui = game:GetService("CoreGui")

-- Динамическое получение LocalPlayer с тайм-аутом
local LocalPlayer
if Players.LocalPlayer then
    LocalPlayer = Players.LocalPlayer
else
    local timeout = 5 -- секунд
    local start = tick()
    while not Players.LocalPlayer and tick() - start < timeout do
        Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
    end
    LocalPlayer = Players.LocalPlayer
    if not LocalPlayer then
        error("Не удалось инициализировать LocalPlayer")
    end
end

-- Дебаг-режим
local debugMode = false
local debugConnections = {} -- Отслеживание всех соединений

local function logDebug(message)
    if debugMode then
        print("[SimpleGUI Debug] " .. tostring(message))
    end
end

-- Вспомогательные функции
local function createInstance(class, parent, props)
    local instance = Instance.new(class)
    if parent then
        instance.Parent = parent
    end
    for prop, value in pairs(props or {}) do
        instance[prop] = value
    end
    return instance
end

local function tween(instance, props, duration, easingStyle)
    if not instance or not instance.Parent then return end
    local tweenInfo = TweenInfo.new(duration, easingStyle or Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tween = TweenService:Create(instance, tweenInfo, props)
    tween:Play()
    return tween
end

-- Основной объект SimpleGUI
function SimpleGUI.new(theme, options)
    local gui = { Windows = {} }
    options = options or {}
    debugMode = options.DebugMode or false
    local scaleFactor = options.UIScale or 1 -- Поддержка масшта  math.clamp(scaleFactor, 0.5, 2) -- Ограничение масштаба

    local screenGui = createInstance("ScreenGui", nil, {
        Name = "SimpleGUI_" .. HttpService:GenerateGUID(false),
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
        DisplayOrder = 100
    })

    -- Универсальная защита GUI для всех эксплойтов
    local success, err = pcall(function()
        local exploitAPIs = {
            { check = function() return syn and syn.protect_gui end, protect = function() syn.protect_gui(screenGui); screenGui.Parent = CoreGui end },
            { check = function() return gethui end, protect = function() screenGui.Parent = gethui() end },
            { check = function() return Krnl and Krnl.ProtectGui end, protect = function() Krnl.ProtectGui(screenGui); screenGui.Parent = CoreGui end },
            { check = function() return Fluxus and Fluxus.protectGui end, protect = function() Fluxus.protectGui(screenGui); screenGui.Parent = CoreGui end },
        }
        for _, api in ipairs(exploitAPIs) do
            if api.check() then
                api.protect()
                logDebug("GUI защищена через " .. tostring(api.check))
                return
            end
        end
        screenGui.Parent = CoreGui
        logDebug("GUI размещена в CoreGui (без защиты)")
    end)
    if not success then
        screenGui.Parent = CoreGui
        logDebug("Ошибка защиты GUI: " .. tostring(err))
    end

    theme = theme or {
        PrimaryColor = Color3.fromRGB(30, 30, 30),
        SecondaryColor = Color3.fromRGB(50, 50, 50),
        TextColor = Color3.fromRGB(200, 200, 200),
        AccentColor = Color3.fromRGB(120, 120, 255),
        Font = Enum.Font.Gotham,
        TextSize = 16
    }

    -- Уведомления (перемещено перед CreateWindow)
    function gui:Notify(config)
        if not config or not config.Title or not config.Content then
            return
        end

        local type = config.Type or "Info"
        local icon = type == "Error" and "❌" or type == "Warning" and "⚠️" or "ℹ️"
        local notification = createInstance("Frame", screenGui, {
            Name = "Notification",
            BackgroundColor3 = theme.PrimaryColor,
            Size = UDim2.new(0, 200 * scaleFactor, 0, 80 * scaleFactor),
            Position = UDim2.new(1, -210 * scaleFactor, 1, -90 * scaleFactor),
            BorderSizePixel = 0,
            ZIndex = 20
        })

        createInstance("UICorner", notification, { CornerRadius = UDim.new(0, 6 * scaleFactor) })

        local titleLabel = createInstance("TextLabel", notification, {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, -10 * scaleFactor, 0, 20 * scaleFactor),
            Position = UDim2.new(0, 5 * scaleFactor, 0, 5 * scaleFactor),
            Font = theme.Font,
            Text = icon .. " " .. config.Title,
            TextColor3 = theme.TextColor,
            TextSize = theme.TextSize * scaleFactor,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 21
        })

        local contentLabel = createInstance("TextLabel", notification, {
            BackgroundTransparency = 1,
            Size = UDim2.new(1, -10 * scaleFactor, 0, 50 * scaleFactor),
            Position = UDim2.new(0, 5 * scaleFactor, 0, 25 * scaleFactor),
            Font = theme.Font,
            Text = config.Content,
            TextColor3 = theme.TextColor,
            TextSize = theme.TextSize * scaleFactor,
            TextXAlignment = Enum.TextXAlignment.Left,
            TextWrapped = true,
            ZIndex = 21
        })

        tween(notification, {Position = UDim2.new(1, -210 * scaleFactor, 1, -100 * scaleFactor)}, 0.3)
        wait(config.Duration or 5)
        tween(notification, {Position = UDim2.new(1, 0, 1, -100 * scaleFactor)}, 0.3).Completed:Connect(function()
            notification:Destroy()
        end)
    end

    -- Создание окна
    function gui:CreateWindow(config)
        if not config or type(config) ~= "table" then
            gui:Notify({
                Title = "Ошибка",
                Content = "Конфигурация окна не предоставлена или неверного типа",
                Type = "Error",
                Duration = 5
            })
            return nil
        end

        local window = {}
        table.insert(gui.Windows, window)
        local draggable = config.Draggable ~= false
        local closable = config.Closable ~= false
        local visible = config.WindowVisible ~= false
        local width = (config.Width or 600) * scaleFactor
        local height = (config.Height or 400) * scaleFactor
        local showCleanupNotification = config.ShowCleanupNotification ~= false
        local configurationSaving = config.ConfigurationSaving or { Enabled = false, FolderName = "SimpleGUI", FileName = "Settings" }

        -- Проверка уникальности   уникальности имени окна
        local windowName = config.Name or "Window"
        for _, w in ipairs(gui.Windows) do
            if w ~= window and w.Name == windowName then
                windowName = windowName .. "_" .. HttpService:GenerateGUID(false)
                break
            end
        end

        local windowFrame = createInstance("Frame", screenGui, {
            Name = windowName,
            BackgroundColor3 = theme.PrimaryColor,
            Position = UDim2.new(0.5, -width / 2, 0.5, -height / 2),
            Size = UDim2.new(0, width, 0, height),
            BorderSizePixel = 0,
            Visible = visible,
            ZIndex = 10
        })

        createInstance("UICorner", windowFrame, { CornerRadius = UDim.new(0, 8 * scaleFactor) })
        createInstance("UIGradient", windowFrame, {
            Color = ColorSequence.new(theme.PrimaryColor, theme.SecondaryColor)
        })

        -- Обновление позиции при изменении размера экрана
        local screenSizeConnection = screenGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
            if not windowFrame or not windowFrame.Parent then return end
            local screenSize = screenGui.AbsoluteSize
            local frameSize = windowFrame.AbsoluteSize
            local newPos = UDim2.new(
                0, math.clamp(windowFrame.Position.X.Offset, 0, screenSize.X - frameSize.X),
                0, math.clamp(windowFrame.Position.Y.Offset, 0, screenSize.Y - frameSize.Y)
            )
            windowFrame.Position = newPos
        end)
        debugConnections[windowName .. "_ScreenSize"] = screenSizeConnection
        logDebug("Создано соединение для отслеживания размера экрана: " .. windowName)

        -- Таблица для отслеживания эффектов
        local activeEffects = {
            connections = {},
            cleanups = {},
            values = {},
            elementNames = {}
        }

        -- Таблица для настроек
        local settings = {}

        -- Функция очистки эффектов
        local function cleanupEffects()
            for key, connection in pairs(activeEffects.connections) do
                if connection and typeof(connection) == "RBXScriptConnection" then
                    pcall(function()
                        if connection.Connected then
                            connection:Disconnect()
                        end
                        logDebug("Отключено соединение: " .. key)
                    end)
                end
            end
            for key, cleanup in pairs(activeEffects.cleanups) do
                if cleanup and type(cleanup) == "function" then
                    pcall(function()
                        cleanup()
                        logDebug("Выполнена очистка: " .. key)
                    end)
                end
            end
            activeEffects.connections = {}
            activeEffects.cleanups = {}
            activeEffects.values = {}
            activeEffects.elementNames = {}
            if showCleanupNotification then
                gui:Notify({
                    Title = "Очистка",
                    Content = "Все эффекты сброшены",
                    Type = "Info",
                    Duration = 3
                })
            end
        end

        -- Сохранение настроек с учётом ограничений DataStore
        local lastSave = 0
        local saveInterval = 10 -- секунд
        function window:SaveConfiguration()
            if not configurationSaving.Enabled then return end
            if tick() - lastSave < saveInterval then return end
            lastSave = tick()
            local data = {}
            for key, value in pairs(activeEffects.values) do
                data[key] = value
            end
            local success, err
            if writefile and readfile then
                success, err = pcall(function()
                    local folder = configurationSaving.FolderName or "SimpleGUI"
                    local file = (configurationSaving.FileName or "Settings") .. ".json"
                    if not isfolder(folder) then
                        makefolder(folder)
                    end
                    writefile(folder .. "/" .. file, HttpService:JSONEncode(data))
                end)
            else
                success, err = pcall(function()
                    local dataStore = DataStoreService:GetDataStore("SimpleGUI")
                    local retryCount = 0
                    local maxRetries = 3
                    while retryCount < maxRetries do
                        local ok, result = pcall(function()
                            dataStore:SetAsync(configurationSaving.FileName or "Settings", data)
                        end)
                        if ok then
                            break
                        end
                        retryCount = retryCount + 1
                        wait(5)
                        logDebug("Повторная попытка сохранения DataStore: " .. retryCount)
                    end
                    if retryCount >= maxRetries then
                        error("Не удалось сохранить данные после нескольких попыток")
                    end
                end)
            end
            if not success then
                gui:Notify({
                    Title = "Ошибка",
                    Content = "Не удалось сохранить настройки: " .. tostring(err),
                    Type = "Error",
                    Duration = 5
                })
            end
        end

        -- Загрузка настроек
        function window:LoadConfiguration()
            if not configurationSaving.Enabled then return end
            local success, data
            if isfile and readfile then
                success, data = pcall(function()
                    local folder = configurationSaving.FolderName or "SimpleGUI"
                    local file = (configurationSaving.FileName or "Settings") .. ".json"
                    if isfile(folder .. "/" .. file) then
                        return HttpService:JSONDecode(readfile(folder .. "/" .. file))
                    end
                    return {}
                end)
            else
                success, data = pcall(function()
                    local dataStore = DataStoreService:GetDataStore("SimpleGUI")
                    return dataStore:GetAsync(configurationSaving.FileName or "Settings") or {}
                end)
            end
            if success and type(data) == "table" then
                settings = data
            else
                gui:Notify({
                    Title = "Ошибка",
                    Content = "Не удалось загрузить настройки: " .. tostring(data),
                    Type = "Error",
                    Duration = 5
                })
            end
        end

        local topbar = createInstance("Frame", windowFrame, {
            Name = "Topbar",
            BackgroundColor3 = theme.SecondaryColor,
            Size = UDim2.new(1, 0, 0, 30 * scaleFactor),
            BorderSizePixel = 0,
            ZIndex = 11
        })

        createInstance("UICorner", topbar, { CornerRadius = UDim.new(0, 6 * scaleFactor) })

        local title = createInstance("TextLabel", topbar, {
            BackgroundTransparency = 1,
            Position = UDim2.new(0.05, 0, 0, 0),
            Size = UDim2.new(0.8, 0, 1, 0),
            Font = theme.Font,
            Text = windowName,
            TextColor3 = theme.TextColor,
            TextSize = theme.TextSize * scaleFactor,
            TextXAlignment = Enum.TextXAlignment.Left,
            ZIndex = 12
        })

        -- Кнопка закрытия
        local closeButton
        if closable then
            closeButton = createInstance("TextButton", topbar, {
                Name = "CloseButton",
                BackgroundColor3 = theme.SecondaryColor,
                Position = UDim2.new(1, -25 * scaleFactor, 0, 5 * scaleFactor),
                Size = UDim2.new(0, 20 * scaleFactor, 0, 20 * scaleFactor),
                Font = theme.Font,
                Text = "X",
                TextColor3 = theme.TextColor,
                TextSize = theme.TextSize * scaleFactor,
                ZIndex = 13
            })

            createInstance("UICorner", closeButton, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

            local closeHover = closeButton.MouseEnter:Connect(function()
                tween(closeButton, {BackgroundColor3 = theme.AccentColor}, 0.2)
            end)
            local closeLeave = closeButton.MouseLeave:Connect(function()
                tween(closeButton, {BackgroundColor3 = theme.SecondaryColor}, 0.2)
            end)
            activeEffects.connections[windowName .. "_CloseHover"] = closeHover
            activeEffects.connections[windowName .. "_CloseLeave"] = closeLeave
            logDebug("Создано соединение для кнопки закрытия: " .. windowName)

            local closeClick = closeButton.MouseButton1Click:Connect(function()
                window:HideWindow()
                tween(closeButton, {Size = UDim2.new(0, 18 * scaleFactor, 0, 18 * scaleFactor)}, 0.1).Completed:Connect(function()
                    tween(closeButton, {Size = UDim2.new(0, 20 * scaleFactor, 0, 20 * scaleFactor)}, 0.1)
                end)
            end)
            activeEffects.connections[windowName .. "_CloseClick"] = closeClick
        end

        -- Логика перемещения
        if draggable then
            local dragging = false
            local dragStart = nil
            local startPos = nil
            local dragConnection

            local dragBegan = topbar.InputBegan:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = true
                    dragStart = input.Position
                    startPos = windowFrame.Position
                    if dragConnection then
                        dragConnection:Disconnect()
                    end
                    dragConnection = UserInputService.InputChanged:Connect(function(input)
                        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                            local delta = input.Position - dragStart
                            local newPos = UDim2.new(
                                startPos.X.Scale,
                                startPos.X.Offset + delta.X,
                                startPos.Y.Scale,
                                startPos.Y.Offset + delta.Y
                            )
                            local screenSize = screenGui.AbsoluteSize
                            local frameSize = windowFrame.AbsoluteSize
                            newPos = UDim2.new(
                                0, math.clamp(newPos.X.Offset, 0, screenSize.X - frameSize.X),
                                0, math.clamp(newPos.Y.Offset, 0, screenSize.Y - frameSize.Y)
                            )
                            windowFrame.Position = newPos
                        end
                    end)
                    activeEffects.connections["Drag"] = dragConnection
                    logDebug("Создано соединение для перетаскивания: " .. windowName)
                end
            end)
            activeEffects.connections["DragBegan"] = dragBegan

            local dragEnded = topbar.InputEnded:Connect(function(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    dragging = false
                    if dragConnection then
                        dragConnection:Disconnect()
                        dragConnection = nil
                        activeEffects.connections["Drag"] = nil
                        logDebug("Отключено соединение перетаскивания: " .. windowName)
                    end
                end
            end)
            activeEffects.connections["DragEnded"] = dragEnded
        end

        -- Боковая панель для вкладок
        local sidebar = createInstance("Frame", windowFrame, {
            Name = "Sidebar",
            BackgroundColor3 = theme.SecondaryColor,
            Position = UDim2.new(0, 0, 0, 30 * scaleFactor),
            Size = UDim2.new(0, 100 * scaleFactor, 1, -30 * scaleFactor),
            BorderSizePixel = 0,
            ZIndex = 11
        })

        createInstance("UICorner", sidebar, { CornerRadius = UDim.new(0, 6 * scaleFactor) })

        local tabButtons = createInstance("Frame", sidebar, {
            Name = "TabButtons",
            BackgroundTransparency = 1,
            Position = UDim2.new(0, 5 * scaleFactor, 0, 5 * scaleFactor),
            Size = UDim2.new(1, -10 * scaleFactor, 1, -10 * scaleFactor),
            ZIndex = 12
        })

        local tabButtonLayout = createInstance("UIListLayout", tabButtons, {
            FillDirection = Enum.FillDirection.Vertical,
            HorizontalAlignment = Enum.HorizontalAlignment.Left,
            SortOrder = Enum.SortOrder.LayoutOrder,
            Padding = UDim.new(0, 5 * scaleFactor)
        })

        local tabContainer = createInstance("Frame", windowFrame, {
            Name = "TabContainer",
            BackgroundTransparency = 1,
            Position = UDim2.new(0, 100 * scaleFactor, 0, 30 * scaleFactor),
            Size = UDim2.new(1, -100 * scaleFactor, 1, -30 * scaleFactor),
            ZIndex = 11
        })

        local tabs = {}
        local activeTab = nil

        -- Создание вкладки
        function window:CreateTab(name, icon)
            if not name then
                gui:Notify({
                    Title = "Ошибка",
                    Content = "Имя вкладки не указано",
                    Type = "Error",
                    Duration = 5
                })
                return nil
            end

            -- Проверка уникальности имени вкладки
            if tabs[name] then
                name = name .. "_" .. HttpService:GenerateGUID(false)
            end

            local tab = {}
            local tabFrame = createInstance("Frame", tabContainer, {
                Name = name,
                BackgroundTransparency = 1,
                Size = UDim2.new(1, 0, 1, 0),
                Visible = false,
                ZIndex = 12
            })

            local tabButton = createInstance("TextButton", tabButtons, {
                Name = name .. "Button",
                BackgroundColor3 = theme.SecondaryColor,
                Size = UDim2.new(1, 0, 0, 30 * scaleFactor),
                Font = theme.Font,
                Text = (icon and icon .. " " or "") .. name,
                TextColor3 = theme.TextColor,
                TextSize = theme.TextSize * scaleFactor,
                TextScaled = false,
                ZIndex = 13
            })

            createInstance("UICorner", tabButton, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

            local tabHover = tabButton.MouseEnter:Connect(function()
                if tabFrame ~= activeTab then
                    tween(tabButton, {BackgroundColor3 = theme.AccentColor:Lerp(theme.SecondaryColor, 0.7)}, 0.2)
                end
            end)
            local tabLeave = tabButton.MouseLeave:Connect(function()
                if tabFrame ~= activeTab then
                    tween(tabButton, {BackgroundColor3 = theme.SecondaryColor}, 0.2)
                end
            end)
            activeEffects.connections[name .. "_TabHover"] = tabHover
            activeEffects.connections[name .. "_TabLeave"] = tabLeave

            local sections = {}

            local function activateTab()
                if activeTab then
                    activeTab.Visible = false
                end
                tabFrame.Visible = true
                activeTab = tabFrame
                for _, btn in pairs(tabButtons:GetChildren()) do
                    if btn:IsA("TextButton") then
                        btn.BackgroundColor3 = theme.SecondaryColor
                    end
                end
                tabButton.BackgroundColor3 = theme.AccentColor
            end

            local tabClick = tabButton.MouseButton1Click:Connect(activateTab)
            activeEffects.connections[name .. "_TabClick"] = tabClick
            if not activeTab then
                activateTab()
            end

            -- Создание секции
            function tab:CreateSection(name)
                if not name then
                    gui:Notify({
                        Title = "Ошибка",
                        Content = "Имя секции не указано",
                        Type = "Error",
                        Duration = 5
                    })
                    return nil
                end

                local section = {}
                local sectionFrame = createInstance("Frame", tabFrame, {
                    Name = name,
                    BackgroundTransparency = 1,
                    Size = UDim2.new(1, -10 * scaleFactor, 0, 0),
                    Position = UDim2.new(0, 5 * scaleFactor, 0, #sections * 10 * scaleFactor),
                    ZIndex = 13
                })

                local sectionTitle = createInstance("TextLabel", sectionFrame, {
                    BackgroundTransparency = 1,
                    Size = UDim2.new(1, 0, 0, 20 * scaleFactor),
                    Font = theme.Font,
                    Text = name,
                    TextColor3 = theme.TextColor,
                    TextSize = theme.TextSize * scaleFactor,
                    TextXAlignment = Enum.TextXAlignment.Left,
                    ZIndex = 14
                })

                local elementContainer = createInstance("Frame", sectionFrame, {
                    BackgroundTransparency = 1,
                    Position = UDim2.new(0, 0, 0, 25 * scaleFactor),
                    Size = UDim2.new(1, 0, 0, 0),
                    ZIndex = 14
                })

                local elementLayout = createInstance("UIListLayout", elementContainer, {
                    SortOrder = Enum.SortOrder.LayoutOrder,
                    Padding = UDim.new(0, 5 * scaleFactor)
                })

                -- Автоматическое обновление размеров
                local layoutConnection = elementLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
                    if not elementContainer or not elementContainer.Parent then return end
                    local contentHeight = elementLayout.AbsoluteContentSize.Y
                    elementContainer.Size = UDim2.new(1, 0, 0, contentHeight)
                    sectionFrame.Size = UDim2.new(1, -10 * scaleFactor, 0, contentHeight + 25 * scaleFactor)
                end)
                activeEffects.connections[name .. "_SectionLayout"] = layoutConnection
                logDebug("Создано соединение для секции: " .. name)

                -- Проверка уникальности имени элемента
                local function checkUniqueName(elementName)
                    if activeEffects.elementNames[elementName] then
                        gui:Notify({
                            Title = "Предупреждение",
                            Content = "Элемент с именем '" .. elementName .. "' уже существует. Используется уникальное имя.",
                            Type = "Warning",
                            Duration = 5
                        })
                        return elementName .. "_" .. HttpService:GenerateGUID(false)
                    end
                    activeEffects.elementNames[elementName] = true
                    return elementName
                end

                -- Создание кнопки
                function section:CreateButton(config)
                    if not config or not config.Name then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация кнопки или её имя не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local button = createInstance("TextButton", elementContainer, {
                        Name = uniqueName,
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 30 * scaleFactor),
                        Font = theme.Font,
                        Text = config.Name,
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        ZIndex = 15
                    })

                    createInstance("UICorner", button, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local buttonClick = button.MouseButton1Click:Connect(function()
                        if config.Callback then
                            local connection, cleanup = config.Callback()
                            if connection and typeof(connection) == "RBXScriptConnection" then
                                activeEffects.connections[uniqueName .. "_Button"] = connection
                                logDebug("Создано соединение для кнопки: " .. uniqueName)
                            end
                            if cleanup and type(cleanup) == "function" then
                                activeEffects.cleanups[uniqueName .. "_Button"] = cleanup
                            end
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_ButtonClick"] = buttonClick

                    local buttonHover = button.MouseEnter:Connect(function()
                        tween(button, {BackgroundColor3 = theme.AccentColor}, 0.2)
                    end)
                    local buttonLeave = button.MouseLeave:Connect(function()
                        tween(button, {BackgroundColor3 = theme.SecondaryColor}, 0.2)
                    end)
                    activeEffects.connections[uniqueName .. "_ButtonHover"] = buttonHover
                    activeEffects.connections[uniqueName .. "_ButtonLeave"] = buttonLeave
                end

                -- Создание переключателя
                function section:CreateToggle(config)
                    if not config or not config.Name then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация переключателя или его имя не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local state = settings[uniqueName] or config.Default or false
                    local toggleFrame = createInstance("Frame", elementContainer, {
                        Name = uniqueName,
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 30 * scaleFactor),
                        ZIndex = 15
                    })

                    local label = createInstance("TextLabel", toggleFrame, {
                        BackgroundTransparency = 1,
                        Size = UDim2.new(0.8, 0, 1, 0),
                        Font = theme.Font,
                        Text = config.Name .. ": " .. (state and "Вкл" or "Выкл"),
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        TextXAlignment = Enum.TextXAlignment.Left,
                        ZIndex = 16
                    })

                    local toggle = createInstance("Frame", toggleFrame, {
                        BackgroundColor3 = state and theme.AccentColor or theme.SecondaryColor,
                        Size = UDim2.new(0, 40 * scaleFactor, 0, 20 * scaleFactor),
                        Position = UDim2.new(1, -40 * scaleFactor, 0.5, -10 * scaleFactor),
                        ZIndex = 16
                    })

                    createInstance("UICorner", toggle, { CornerRadius = UDim.new(0, 10 * scaleFactor) })

                    local circle = createInstance("Frame", toggle, {
                        BackgroundColor3 = theme.TextColor,
                        Size = UDim2.new(0, 16 * scaleFactor, 0, 16 * scaleFactor),
                        Position = state and UDim2.new(1, -18 * scaleFactor, 0.5, -8 * scaleFactor) or UDim2.new(0, 2 * scaleFactor, 0.5, -8 * scaleFactor),
                        ZIndex = 17
                    })

                    createInstance("UICorner", circle, { CornerRadius = UDim.new(0, 8 * scaleFactor) })

                    local toggleClick = toggleFrame.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            state = not state
                            tween(circle, {Position = state and UDim2.new(1, -18 * scaleFactor, 0.5, -8 * scaleFactor) or UDim2.new(0, 2 * scaleFactor, 0.5, -8 * scaleFactor)}, 0.2)
                            tween(toggle, {BackgroundColor3 = state and theme.AccentColor or theme.SecondaryColor}, 0.2)
                            label.Text = config.Name .. ": " .. (state and "Вкл" or "Выкл")
                            activeEffects.values[uniqueName] = state
                            window:SaveConfiguration()
                            if config.Callback then
                                local connection, cleanup = config.Callback(state)
                                if connection and typeof(connection) == "RBXScriptConnection" then
                                    activeEffects.connections[uniqueName .. "_Toggle"] = connection
                                    logDebug("Создано соединение для переключателя: " .. uniqueName)
                                end
                                if cleanup and type(cleanup) == "function" then
                                    activeEffects.cleanups[uniqueName .. "_Toggle"] = cleanup
                                end
                            end
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_ToggleClick"] = toggleClick
                end

                -- Создание слайдера
                function section:CreateSlider(config)
                    if not config or not config.Name or not config.Min or not config.Max then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация слайдера или его параметры не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local value = settings[uniqueName] or config.Default or config.Min
                    local sliderFrame = createInstance("Frame", elementContainer, {
                        Name = uniqueName,
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 50 * scaleFactor),
                        ZIndex = 15
                    })

                    local label = createInstance("TextLabel", sliderFrame, {
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, 0, 0, 20 * scaleFactor),
                        Font = theme.Font,
                        Text = config.Name .. ": " .. value,
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        ZIndex = 16
                    })

                    local sliderBar = createInstance("Frame", sliderFrame, {
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(1, 0, 0, 10 * scaleFactor),
                        Position = UDim2.new(0, 0, 0, 25 * scaleFactor),
                        ZIndex = 16
                    })

                    createInstance("UICorner", sliderBar, { CornerRadius = UDim.new(0, 5 * scaleFactor) })

                    local fill = createInstance("Frame", sliderBar, {
                        BackgroundColor3 = theme.AccentColor,
                        Size = UDim2.new((value - config.Min) / (config.Max - config.Min), 0, 1, 0),
                        ZIndex = 17
                    })

                    createInstance("UICorner", fill, { CornerRadius = UDim.new(0, 5 * scaleFactor) })

                    local dragging = false
                    local beganConnection = sliderBar.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            dragging = true
                        end
                    end)
                    local endedConnection = sliderBar.InputEnded:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            dragging = false
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_SliderBegan"] = beganConnection
                    activeEffects.connections[uniqueName .. "_SliderEnded"] = endedConnection
                    logDebug("Создано соединение для слайдера: " .. uniqueName)

                    local changedConnection = UserInputService.InputChanged:Connect(function(input)
                        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                            local relativeX = (input.Position.X - sliderBar.AbsolutePosition.X) / sliderBar.AbsoluteSize.X
                            relativeX = math.clamp(relativeX, 0, 1)
                            value = math.floor(config.Min + (config.Max - config.Min) * relativeX)
                            fill.Size = UDim2.new(relativeX, 0, 1, 0)
                            label.Text = config.Name .. ": " .. value
                            activeEffects.values[uniqueName] = value
                            window:SaveConfiguration()
                            if config.Callback then
                                local connection, cleanup = config.Callback(value)
                                if connection and typeof(connection) == "RBXScriptConnection" then
                                    activeEffects.connections[uniqueName .. "_SliderCallback"] = connection
                                    logDebug("Создано соединение для слайдера (Callback): " .. uniqueName)
                                end
                                if cleanup and type(cleanup) == "function" then
                                    activeEffects.cleanups[uniqueName .. "_SliderCallback"] = cleanup
                                end
                            end
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_SliderChanged"] = changedConnection
                end

                -- Создание текстового поля
                function section:CreateTextbox(config)
                    if not config or not config.Name then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация текстового поля или его имя не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local value = settings[uniqueName] or config.Default or ""
                    local textbox = createInstance("TextBox", elementContainer, {
                        Name = uniqueName,
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 30 * scaleFactor),
                        Font = theme.Font,
                        Text = value,
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        ZIndex = 15
                    })

                    createInstance("UICorner", textbox, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local focusLostConnection = textbox.FocusLost:Connect(function()
                        value = textbox.Text
                        activeEffects.values[uniqueName] = value
                        window:SaveConfiguration()
                        if config.Callback then
                            local connection, cleanup = config.Callback(value)
                            if connection and typeof(connection) == "RBXScriptConnection" then
                                activeEffects.connections[uniqueName .. "_Textbox"] = connection
                                logDebug("Создано соединение для текстового поля: " .. uniqueName)
                            end
                            if cleanup and type(cleanup) == "function" then
                                activeEffects.cleanups[uniqueName .. "_Textbox"] = cleanup
                            end
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_TextboxFocusLost"] = focusLostConnection
                end

                -- Создание выпадающего списка
                function section:CreateDropdown(config)
                    if not config or not config.Name or not config.Options then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация выпадающего списка или его параметры не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local selected = settings[uniqueName] or config.Default or config.Options[1]
                    local isOpen = false
                    local dropdownFrame = createInstance("Frame", elementContainer, {
                        Name = uniqueName,
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 30 * scaleFactor),
                        ZIndex = 15
                    })

                    local label = createInstance("TextLabel", dropdownFrame, {
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -30 * scaleFactor, 1, 0),
                        Font = theme.Font,
                        Text = config.Name .. ": " .. selected,
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        TextXAlignment = Enum.TextXAlignment.Left,
                        ZIndex = 16
                    })

                    local toggleButton = createInstance("TextButton", dropdownFrame, {
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(0, 20 * scaleFactor, 0, 20 * scaleFactor),
                        Position = UDim2.new(1, -25 * scaleFactor, 0.5, -10 * scaleFactor),
                        Font = theme.Font,
                        Text = isOpen and "▲" or "▼",
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        ZIndex = 16
                    })

                    createInstance("UICorner", toggleButton, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local optionContainer = createInstance("Frame", dropdownFrame, {
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(1, 0, 0, 0),
                        Position = UDim2.new(0, 0, 1, 0),
                        Visible = false,
                        ClipsDescendants = true,
                        ZIndex = 17
                    })

                    createInstance("UICorner", optionContainer, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local optionLayout = createInstance("UIListLayout", optionContainer, {
                        SortOrder = Enum.SortOrder.LayoutOrder,
                        Padding = UDim.new(0, 2 * scaleFactor)
                    })

                    local options = {}
                    for i, option in ipairs(config.Options) do
                        local optionButton = createInstance("TextButton", optionContainer, {
                            BackgroundColor3 = theme.SecondaryColor,
                            Size = UDim2.new(1, 0, 0, 20 * scaleFactor),
                            Font = theme.Font,
                            Text = option,
                            TextColor3 = theme.TextColor,
                            TextSize = theme.TextSize * scaleFactor,
                            ZIndex = 18
                        })

                        createInstance("UICorner", optionButton, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                        local clickConnection = optionButton.MouseButton1Click:Connect(function()
                            selected = option
                            label.Text = config.Name .. ": " .. selected
                            isOpen = false
                            toggleButton.Text = "▼"
                            optionContainer.Visible = false
                            tween(optionContainer, {Size = UDim2.new(1, 0, 0, 0)}, 0.2)
                            activeEffects.values[uniqueName] = selected
                            window:SaveConfiguration()
                            if config.Callback then
                                local connection, cleanup = config.Callback(selected)
                                if connection and typeof(connection) == "RBXScriptConnection" then
                                    activeEffects.connections[uniqueName .. "_Dropdown"] = connection
                                    logDebug("Создано соединение для выпадающего списка: " .. uniqueName)
                                end
                                if cleanup and type(cleanup) == "function" then
                                    activeEffects.cleanups[uniqueName .. "_Dropdown"] = cleanup
                                end
                            end
                        end)
                        activeEffects.connections[uniqueName .. "_DropdownOption_" .. i] = clickConnection
                        options[option] = optionButton
                    end

                    local toggleConnection = toggleButton.MouseButton1Click:Connect(function()
                        isOpen = not isOpen
                        toggleButton.Text = isOpen and "▲" or "▼"
                        optionContainer.Visible = isOpen
                        local height = isOpen and (#config.Options * 22 * scaleFactor) or 0
                        tween(optionContainer, {Size = UDim2.new(1, 0, 0, height)}, 0.2)
                    end)
                    activeEffects.connections[uniqueName .. "_DropdownToggle"] = toggleConnection
                end

                -- Создание привязки клавиш
                function section:CreateKeybind(config)
                    if not config or not config.Name then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация привязки клавиш или её имя не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local key = settings[uniqueName] or config.Default or Enum.KeyCode.Unknown
                    local keybindFrame = createInstance("Frame", elementContainer, {
                        Name = uniqueName,
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 30 * scaleFactor),
                        ZIndex = 15
                    })

                    local label = createInstance("TextLabel", keybindFrame, {
                        BackgroundTransparency = 1,
                        Size = UDim2.new(0.8, 0, 1, 0),
                        Font = theme.Font,
                        Text = config.Name .. ": " .. (key == Enum.KeyCode.Unknown and "None" or key.Name),
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        TextXAlignment = Enum.TextXAlignment.Left,
                        ZIndex = 16
                    })

                    local bindButton = createInstance("TextButton", keybindFrame, {
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(0, 60 * scaleFactor, 0, 20 * scaleFactor),
                        Position = UDim2.new(1, -65 * scaleFactor, 0.5, -10 * scaleFactor),
                        Font = theme.Font,
                        Text = "Bind",
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        ZIndex = 16
                    })

                    createInstance("UICorner", bindButton, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local binding = false
                    local isProcessing = false
                    local bindConnection = bindButton.MouseButton1Click:Connect(function()
                        if not isProcessing then
                            binding = true
                            bindButton.Text = "Нажмите клавишу..."
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_KeybindBind"] = bindConnection
                    logDebug("Создано соединение для кнопки привязки: " .. uniqueName)

                    if activeEffects.connections[uniqueName .. "_KeybindBinding"] then
                        activeEffects.connections[uniqueName .. "_KeybindBinding"]:Disconnect()
                        activeEffects.connections[uniqueName .. "_KeybindBinding"] = nil
                        logDebug("Отключено старое соединение привязки: " .. uniqueName)
                    end

                    local connection = UserInputService.InputBegan:Connect(function(input)
                        if binding and input.UserInputType == Enum.UserInputType.Keyboard and not isProcessing then
                            isProcessing = true
                            key = input.KeyCode
                            label.Text = config.Name .. ": " .. (key == Enum.KeyCode.Unknown and "None" or key.Name)
                            bindButton.Text = "Bind"
                            binding = false
                            activeEffects.values[uniqueName] = key
                            window:SaveConfiguration()
                            connection:Disconnect()
                            activeEffects.connections[uniqueName .. "_KeybindBinding"] = nil
                            logDebug("Отключено соединение привязки: " .. uniqueName)
                            if config.Callback then
                                if activeEffects.connections[uniqueName .. "_Keybind"] then
                                    activeEffects.connections[uniqueName .. "_Keybind"]:Disconnect()
                                    logDebug("Отключено старое соединение Callback: " .. uniqueName)
                                end
                                local cbConnection, cleanup = config.Callback(key)
                                if cbConnection and typeof(cbConnection) == "RBXScriptConnection" then
                                    activeEffects.connections[uniqueName .. "_Keybind"] = cbConnection
                                    logDebug("Создано соединение Callback для привязки: " .. uniqueName)
                                end
                                if cleanup and type(cleanup) == "function" then
                                    activeEffects.cleanups[uniqueName .. "_Keybind"] = cleanup
                                end
                            end
                            isProcessing = false
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_KeybindBinding"] = connection
                end

                -- Создание цветовой палитры
                function section:CreateColorPicker(config)
                    if not config or not config.Name then
                        gui:Notify({
                            Title = "Ошибка",
                            Content = "Конфигурация цветовой палитры или её имя не указаны",
                            Type = "Error",
                            Duration = 5
                        })
                        return
                    end

                    local uniqueName = checkUniqueName(config.Name)
                    local color = settings[uniqueName] or config.Default or Color3.fromRGB(255, 255, 255)
                    local colorPickerFrame = createInstance("Frame", elementContainer, {
                        Name = uniqueName,
                        BackgroundTransparency = 1,
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 30 * scaleFactor),
                        ZIndex = 15
                    })

                    local label = createInstance("TextLabel", colorPickerFrame, {
                        BackgroundTransparency = 1,
                        Size = UDim2.new(0.8, 0, 1, 0),
                        Font = theme.Font,
                        Text = config.Name .. ": RGB(" .. math.floor(color.R * 255) .. "," .. math.floor(color.G * 255) .. "," .. math.floor(color.B * 255) .. ")",
                        TextColor3 = theme.TextColor,
                        TextSize = theme.TextSize * scaleFactor,
                        TextXAlignment = Enum.TextXAlignment.Left,
                        ZIndex = 16
                    })

                    local colorBox = createInstance("Frame", colorPickerFrame, {
                        BackgroundColor3 = color,
                        Size = UDim2.new(0, 20 * scaleFactor, 0, 20 * scaleFactor),
                        Position = UDim2.new(1, -25 * scaleFactor, 0.5, -10 * scaleFactor),
                        ZIndex = 16
                    })

                    createInstance("UICorner", colorBox, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local pickerFrame = createInstance("Frame", colorPickerFrame, {
                        BackgroundColor3 = theme.SecondaryColor,
                        Size = UDim2.new(1, 0, 0, 0),
                        Position = UDim2.new(0, 0, 1, 0),
                        Visible = false,
                        ClipsDescendants = true,
                        ZIndex = 17
                    })

                    createInstance("UICorner", pickerFrame, { CornerRadius = UDim.new(0, 4 * scaleFactor) })

                    local hueBar = createInstance("Frame", pickerFrame, {
                        BackgroundColor3 = Color3.fromRGB(255, 255, 255),
                        Size = UDim2.new(1, -10 * scaleFactor, 0, 10 * scaleFactor),
                        Position = UDim2.new(0, 5 * scaleFactor, 0, 5 * scaleFactor),
                        ZIndex = 18
                    })

                    createInstance("UIGradient", hueBar, {
                        Color = ColorSequence.new({
                            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
                            ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 255, 0)),
                            ColorSequenceKeypoint.new(0.33, Color3.fromRGB(0, 255, 0)),
                            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 255)),
                            ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 0, 255)),
                            ColorSequenceKeypoint.new(0.83, Color3.fromRGB(255, 0, 255)),
                            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 0))
                        })
                    })

                    local hueMarker = createInstance("Frame", hueBar, {
                        BackgroundColor3 = theme.TextColor,
                        Size = UDim2.new(0, 4 * scaleFactor, 1, 0),
                        Position = UDim2.new(0, 0, 0, 0),
                        ZIndex = 19
                    })

                    local isOpen = false
                    local dragging = false
                    local openConnection = colorBox.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            isOpen = not isOpen
                            pickerFrame.Visible = isOpen
                            tween(pickerFrame, {Size = UDim2.new(1, 0, 0, isOpen and 20 * scaleFactor or 0)}, 0.2)
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_ColorPickerOpen"] = openConnection
                    logDebug("Создано соединение для открытия ColorPicker: " .. uniqueName)

                    local beganConnection = hueBar.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            dragging = true
                        end
                    end)
                    local endedConnection = hueBar.InputEnded:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                            dragging = false
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_ColorPickerBegan"] = beganConnection
                    activeEffects.connections[uniqueName .. "_ColorPickerEnded"] = endedConnection
                    logDebug("Создано соединение для ColorPicker (Input): " .. uniqueName)

                    if activeEffects.connections[uniqueName .. "_ColorPickerChanged"] then
                        activeEffects.connections[uniqueName .. "_ColorPickerChanged"]:Disconnect()
                        activeEffects.connections[uniqueName .. "_ColorPickerChanged"] = nil
                        logDebug("Отключено старое соединение ColorPicker: " .. uniqueName)
                    end

                    local changedConnection = UserInputService.InputChanged:Connect(function(input)
                        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                            local relativeX = (input.Position.X - hueBar.AbsolutePosition.X) / hueBar.AbsoluteSize.X
                            relativeX = math.clamp(relativeX, 0, 1)
                            local hue = relativeX
                            local h, s, v = Color3.toHSV(color)
                            color = Color3.fromHSV(hue, s, v)
                            colorBox.BackgroundColor3 = color
                            hueMarker.Position = UDim2.new(relativeX, -2 * scaleFactor, 0, 0)
                            label.Text = config.Name .. ": RGB(" .. math.floor(color.R * 255) .. "," .. math.floor(color.G * 255) .. "," .. math.floor(color.B * 255) .. ")"
                            activeEffects.values[uniqueName] = color
                            window:SaveConfiguration()
                            if config.Callback then
                                local connection, cleanup = config.Callback(color)
                                if connection and typeof(connection) == "RBXScriptConnection" then
                                    activeEffects.connections[uniqueName .. "_ColorPickerCallback"] = connection
                                    logDebug("Создано соединение для ColorPicker (Callback): " .. uniqueName)
                                end
                                if cleanup and type(cleanup) == "function" then
                                    activeEffects.cleanups[uniqueName .. "_ColorPickerCallback"] = cleanup
                                end
                            end
                        end
                    end)
                    activeEffects.connections[uniqueName .. "_ColorPickerChanged"] = changedConnection
                end

                table.insert(sections, sectionFrame)
                return section
            end

            tabs[name] = tab
            return tab
        end

        -- Показать окно
        function window:ShowWindow()
            if not windowFrame or not windowFrame.Parent then
                gui:Notify({
                    Title = "Ошибка",
                    Content = "Окно было уничтожено",
                    Type = "Error",
                    Duration = 5
                })
                return
            end
            if not windowFrame.Visible then
                windowFrame.Visible = true
                windowFrame.Size = UDim2.new(0, width * 0.9, 0, height * 0.9)
                tween(windowFrame, {Size = UDim2.new(0, width, 0, height), Transparency = 0}, 0.3)
            end
        end

        -- Скрыть окно
        function window:HideWindow()
            if not windowFrame or not windowFrame.Parent then
                gui:Notify({
                    Title = "Ошибка",
                    Content = "Окно было уничтожено",
                    Type = "Error",
                    Duration = 5
                })
                return
            end
            if windowFrame.Visible then
                cleanupEffects()
                tween(windowFrame, {Size = UDim2.new(0, width * 0.9, 0, height * 0.9), Transparency = 0.8}, 0.3).Completed:Connect(function()
                    if windowFrame and windowFrame.Parent then
                        windowFrame.Visible = false
                        windowFrame.Transparency = 0
                    end
                end)
            end
        end

        -- Переключить видимость окна
        function window:ToggleWindow()
            if not windowFrame or not windowFrame.Parent then
                gui:Notify({
                    Title = "Ошибка",
                    Content = "Окно было уничтожено",
                    Type = "Error",
                    Duration = 5
                })
                return
            end
            if windowFrame.Visible then
                window:HideWindow()
            else
                window:ShowWindow()
            end
        end

        -- Удалить окно
        function window:Destroy()
            cleanupEffects()
            for i, w in ipairs(gui.Windows) do
                if w == window then
                    table.remove(gui.Windows, i)
                    break
                end
            end
            if windowFrame then
                windowFrame:Destroy()
                windowFrame = nil
                logDebug("Окно уничтожено: " .. windowName)
            end
        end

        window.Visible = windowFrame.Visible
        window.Name = windowName
        window:LoadConfiguration()

        -- Интеграция с Roblox
        local playerAddedConnection = Players.PlayerAdded:Connect(function(player)
            if player == LocalPlayer then
                window:ShowWindow()
            end
        end)
        activeEffects.connections["PlayerAdded"] = playerAddedConnection
        logDebug("Создано соединение для PlayerAdded: " .. windowName)

        return window
    end

    -- Переключение всех окон
    function gui:ToggleAllWindows()
        for _, window in ipairs(gui.Windows) do
            window:ToggleWindow()
        end
    end

    -- Включение/выключение дебаг-режима
    function gui:SetDebugMode(enabled)
        debugMode = enabled
        logDebug("Дебаг-режим " .. (enabled and "включён" or "выключен"))
    end

    return gui
end

return SimpleGUI
--嫌いなものがある場合は、それを教えてください。
